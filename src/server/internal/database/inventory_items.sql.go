// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: inventory_items.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addItemsToInventory = `-- name: AddItemsToInventory :one
INSERT INTO inventory_items(id, inventory_id, item_id, quantity, updated_at, created_at)
VALUES (gen_random_uuid(), $1, $2, $3, NOW(), NOW())
ON CONFLICT (inventory_id, item_id) 
DO UPDATE SET
	quantity = inventory_items.quantity + EXCLUDED.quantity,
	updated_at = NOW()
RETURNING id, item_id, inventory_id, quantity, created_at, updated_at
`

type AddItemsToInventoryParams struct {
	InventoryID pgtype.UUID
	ItemID      int32
	Quantity    int32
}

func (q *Queries) AddItemsToInventory(ctx context.Context, arg AddItemsToInventoryParams) (InventoryItem, error) {
	row := q.db.QueryRow(ctx, addItemsToInventory, arg.InventoryID, arg.ItemID, arg.Quantity)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.ItemID,
		&i.InventoryID,
		&i.Quantity,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const batchAddItemsToInventory = `-- name: BatchAddItemsToInventory :exec
INSERT INTO inventory_items(id, inventory_id, item_id, quantity, updated_at, created_at)
SELECT gen_random_uuid(), unnest($1::UUID[]), unnest($2::INTEGER[]), unnest($3::INTEGER[]), NOW(), NOW()
ON CONFLICT (inventory_id, item_id) 
DO UPDATE SET
	quantity = inventory_items.quantity + EXCLUDED.quantity,
	updated_at = NOW()
`

type BatchAddItemsToInventoryParams struct {
	Column1 []pgtype.UUID
	Column2 []int32
	Column3 []int32
}

func (q *Queries) BatchAddItemsToInventory(ctx context.Context, arg BatchAddItemsToInventoryParams) error {
	_, err := q.db.Exec(ctx, batchAddItemsToInventory, arg.Column1, arg.Column2, arg.Column3)
	return err
}

const getInventoryItemsByInventoryId = `-- name: GetInventoryItemsByInventoryId :many
SELECT id, item_id, inventory_id, quantity, created_at, updated_at FROM inventory_items
WHERE inventory_id = $1
`

func (q *Queries) GetInventoryItemsByInventoryId(ctx context.Context, inventoryID pgtype.UUID) ([]InventoryItem, error) {
	rows, err := q.db.Query(ctx, getInventoryItemsByInventoryId, inventoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InventoryItem
	for rows.Next() {
		var i InventoryItem
		if err := rows.Scan(
			&i.ID,
			&i.ItemID,
			&i.InventoryID,
			&i.Quantity,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
